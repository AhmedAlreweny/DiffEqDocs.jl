<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ODE Solvers · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations (ODE)</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations (SDE)</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations (DAE)</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li><li><a class="toctext" href="../types/stokes_types.html">Stokes Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li class="current"><a class="toctext" href="ode_solve.html">ODE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li><li><a class="toctext" href="#List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></li><li><a class="toctext" href="#Solver-Compatibility-and-Defaults-Chart-1">Solver Compatibility and Defaults Chart</a></li></ul></li><li><a class="toctext" href="sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="femheat_solve.html">FEM Heat Solvers</a></li><li><a class="toctext" href="fdmstokes_solve.html">Stokes Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/output_specification.html">Output Specification</a></li><li><a class="toctext" href="../features/conditional_dependencies.html">Conditional Dependencies</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href="ode_solve.html">ODE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/5f8dd3dc5e6d0f2518ce95a07fbf283c2b9e37fc/docs/src/solvers/ode_solve.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="ODE-Solvers-1" href="#ODE-Solvers-1">ODE Solvers</a></h1><p><code>solve(prob::ODEProblem,alg;kwargs)</code></p><p>Solves the ODE defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2><a class="nav-anchor" id="Recommended-Methods-1" href="#Recommended-Methods-1">Recommended Methods</a></h2><p>It is suggested that you try choosing an algorithm using the <code>alg_hints</code> keyword argument. However, in some cases you may want something specific, or you may just be curious. This guide is to help you choose the right algorithm.</p><h3><a class="nav-anchor" id="Non-Stiff-Problems-1" href="#Non-Stiff-Problems-1">Non-Stiff Problems</a></h3><p>For non-stiff problems, the native OrdinaryDiffEq.jl algorithms are vastly more efficient than the other choices. For most non-stiff problems, we recommend <code>Tsit5</code>. When more robust error control is required, <code>BS5</code> is a good choice. For fast solving at lower tolerances, we recommend <code>BS3</code>. For tolerances which are at about the truncation error of Float64 (1e-16), we recommend <code>Vern6</code>, <code>Vern7</code>, or <code>Vern8</code> as efficient choices.</p><p>For high accuracy non-stiff solving (BigFloat and tolerances like <code>&lt;1e-20</code>), we recommend the <code>Feagin12</code> or <code>Feagin14</code> methods. These are more robust than Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods. Note that the Feagin methods are the only high-order optimized methods which do not include a high-order interpolant (they do include a 3rd order Hermite interpolation if needed). If a high-order method is needed with a high order interpolant, then you should choose <code>Vern9</code> which is Order 9 with an Order 9 interpolant.</p><h3><a class="nav-anchor" id="Stiff-Problems-1" href="#Stiff-Problems-1">Stiff Problems</a></h3><p>For mildly stiff problems at low tolerances it is recommended that you use <code>Rosenbrock23</code> As a native DifferentialEquations.jl solver, many Julia-defined numbers will work. This method uses ForwardDiff to automatically guess the Jacobian. For faster solving when the Jacobian is known, use <code>radau</code>. For highly stiff problems where Julia-defined numbers need to be used (SIUnits, Arbs), <code>Trapezoid</code> is the current best choice. However, for the most efficient highly stiff solvers, use <code>radau</code> or <code>CVODE_BDF</code> provided by wrappers to the ODEInterface and Sundials packages respectively (<a href="http://juliadiffeq.github.io/DifferentialEquations.jl/latest/man/conditional_dependencies.html">see the conditional dependencies documentation</a>). These algorithms require that the number types are Float64.</p><h2><a class="nav-anchor" id="Full-List-of-Methods-1" href="#Full-List-of-Methods-1">Full List of Methods</a></h2><p>Choose one of these methods with the <code>alg</code> keyword in <code>solve</code>.</p><h3><a class="nav-anchor" id="OrdinaryDiffEq.jl-1" href="#OrdinaryDiffEq.jl-1">OrdinaryDiffEq.jl</a></h3><p>Unless otherwise specified, the OrdinaryDiffEq algorithms all come with a 3rd order Hermite polynomial interpolation. The algorithms denoted as having a &quot;free&quot; interpolation means that no extra steps are required for the interpolation. For the non-free higher order interpolating functions, the extra steps are computed lazily (i.e. not during the solve).</p><p>The OrdinaryDiffEq.jl algorithms achieve the highest performance for nonstiff equations while being the most generic: accepting the most Julia-based types, allow for sophisticated event handling, etc. They are recommended for all nonstiff problems. For stiff problems, the algorithms are currently not as high of order or as well-optimized as the ODEInterface.jl or Sundials.jl algorithms, and thus if the problem is on arrays of Float64, they are recommended. However, the stiff methods from OrdinaryDiffEq.jl are able to handle a larger generality of number types (arbitrary precision, etc.) and thus are recommended for stiff problems on for non-Float64 numbers.</p><ul><li><p><code>Euler</code>- The canonical forward Euler method.</p></li><li><p><code>Midpoint</code> - The second order midpoint method.</p></li><li><p><code>RK4</code> - The canonical Runge-Kutta Order 4 method.</p></li><li><p><code>BS3</code> - Bogacki-Shampine 3/2 method.</p></li><li><p><code>DP5</code> - Dormand-Prince&#39;s 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>Tsit5</code> - Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>BS5</code> - Bogacki-Shampine 5/4 Runge-Kutta method. (5th order interpolant)</p></li><li><p><code>Vern6</code> - Verner&#39;s &quot;Most Efficient&quot; 6/5 Runge-Kutta method. (6th order interpolant)</p></li><li><p><code>Vern7</code> - Verner&#39;s &quot;Most Efficient&quot; 7/6 Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TanYam7</code> - Tanaka-Yamashita 7 Runge-Kutta method.</p></li><li><p><code>DP8</code> - Hairer&#39;s 8/5/3 adaption of the Dormand-Prince 8 method Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TsitPap8</code> - Tsitouras-Papakostas 8/7 Runge-Kutta method.</p></li><li><p><code>Vern8</code> - Verner&#39;s &quot;Most Efficient&quot; 8/7 Runge-Kutta method. (8th order interpolant)</p></li><li><p><code>Vern9</code> - Verner&#39;s &quot;Most Efficient&quot; 9/8 Runge-Kutta method. (9th order interpolant)</p></li><li><p><code>Feagin10</code> - Feagin&#39;s 10th-order Runge-Kutta method.</p></li><li><p><code>Feagin12</code> - Feagin&#39;s 12th-order Runge-Kutta method.</p></li><li><p><code>Feagin14</code> - Feagin&#39;s 14th-order Runge-Kutta method.</p></li><li><p><code>ExplicitRK</code> - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument <code>tab=tableau</code>. The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.</p></li><li><p><code>ImplicitEuler</code> - A 1st order implicit solver. Unconditionally stable.</p></li><li><p><code>Trapezoid</code> - A second order unconditionally stable implicit solver. Good for highly stiff.</p></li><li><p><code>Rosenbrock23</code> - An Order 2/3 L-Stable fast solver which is good for mildy stiff equations with oscillations at low tolerances.</p></li><li><p><code>Rosenbrock32</code> - An Order 3/2 A-Stable fast solver which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution.</p></li></ul><h3><a class="nav-anchor" id="ODEInterface.jl-1" href="#ODEInterface.jl-1">ODEInterface.jl</a></h3><p>The ODEInterface algorithms are the classic Hairer Fortran algorithms. While the nonstiff algorithms are superseded by the more featured and higher performance Julia implementations from OrdinaryDiffEq.jl, the stiff solvers such as <code>radau</code> are some of the most efficient methods available (but are restricted for use on arrays of Float64).</p><ul><li><p><code>dopri5</code> - Hairer&#39;s classic implementation of the Dormand-Prince 4/5 method.</p></li><li><p><code>dop853</code> - Explicit Runge-Kutta 8(5,3) by Dormand-Prince</p></li><li><p><code>odex</code> - GBS extrapolation-algorithm based on the midpoint rule</p></li><li><p><code>seulex</code> - extrapolation-algorithm based on the linear implicit Euler method</p></li><li><p><code>radau</code> - implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13</p></li><li><p><code>radau5</code> - implicit Runge-Kutta method (Radau IIA) of order 5</p></li></ul><h3><a class="nav-anchor" id="Sundials.jl-1" href="#Sundials.jl-1">Sundials.jl</a></h3><p>The Sundials suite is built around multistep methods. These methods are more efficient than other methods when the cost of the function calculations is really high, but for less costly functions the cost of nurturing the timestep overweighs the benefits. However, the BDF method is a classic method for stiff equations and &quot;generally works&quot;.</p><ul><li><p><code>CVODE_BDF</code> - CVode Backward Differentiation Formula (BDF) solver.</p></li><li><p><code>CVODE_Adams</code> - CVode Adams-Moulton solver</p></li></ul><p>Note that the constructors for the Sundials algorithms take two arguments:</p><ul><li><p><code>method</code> - This is the method for solving the implicit equation. For BDF this defaults to <code>:Newton</code> while for Adams this defaults to <code>:Functional</code>. These choices match the recommended pairing in the Sundials.jl manual. However, note that using the <code>:Newton</code> method may take less iterations but requires more memory than the <code>:Function</code> iteration approach.</p></li><li><p><code>linearsolver</code> - This is the linear solver which is used in the <code>:Newton</code> method. Currently the only choice is the default which is <code>:Dense</code>.</p></li></ul><p>Example:</p><pre><code class="language-julia">CVODE_BDF() # BDF method using Newton + Dense solver
CVODE_BDF(method=:Functional) # BDF method using Functional iterations</code></pre><h3><a class="nav-anchor" id="ODE.jl-1" href="#ODE.jl-1">ODE.jl</a></h3><p>The ODE.jl algorithms all come with a 3rd order Hermite polynomial interpolation.</p><ul><li><p><code>rk23</code> - Bogakai-Shampine&#39;s 2/3 method</p></li><li><p><code>rk45</code> - Dormand-Prince&#39;s 4/5 method</p></li><li><p><code>feh78</code> - Runge-Kutta-Fehlberg 7/8 method</p></li><li><p><code>ModifiedRosenbrockIntegrator</code> - Rosenbrock&#39;s 2/3 method</p></li><li><p><code>feuler</code> - Forward Euler</p></li><li><p><code>midpoint</code> - Midpoint Method</p></li><li><p><code>heun</code> - Heun&#39;s Method</p></li><li><p><code>rk4</code> - RK4</p></li><li><p><code>feh45</code> - Runge-Kutta-Fehlberg 4/5 method</p></li></ul><h2><a class="nav-anchor" id="List-of-Supplied-Tableaus-1" href="#List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></h2><p>A large variety of tableaus have been supplied by default via DiffEqDevTools.jl. The list of tableaus can be found in <a href="https://juliadiffeq.github.io/DiffEqDevDocs.jl/latest/internals/tableaus.html">the developer docs</a>. For the most useful and common algorithms, a hand-optimized version is supplied and is recommended for general uses (i.e. use <code>DP5</code> instead of <code>ExplicitRK</code> with <code>tableau=constructDormandPrince()</code>). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exist). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the <a href="https://github.com/JuliaDiffEq/DiffEqDevTools.jl/blob/master/src/ode_tableaus.jl">premade tableau source code</a>. Tableau docstrings should have appropriate citations (if not, file an issue).</p><p>Plot recipes are provided which will plot the stability region for a given tableau.</p><h2><a class="nav-anchor" id="Solver-Compatibility-and-Defaults-Chart-1" href="#Solver-Compatibility-and-Defaults-Chart-1">Solver Compatibility and Defaults Chart</a></h2><p>The following chart describes the compatibility and defaults of the specific solvers to the common interface.</p><footer><hr/><a class="previous" href="../types/stokes_types.html"><span class="direction">Previous</span><span class="title">Stokes Types</span></a><a class="next" href="sde_solve.html"><span class="direction">Next</span><span class="title">SDE Solvers</span></a></footer></article></body></html>
