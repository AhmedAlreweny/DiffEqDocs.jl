<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Monte Carlo Simulations · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Types</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/refined_ode_types.html">Refined ODE Types</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Types</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/refined_dae_types.html">Refined DAE Types</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li class="current"><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a><ul class="internal"><li><a class="toctext" href="#Performing-a-Monte-Carlo-Simulation-1">Performing a Monte Carlo Simulation</a></li><li><a class="toctext" href="#Analyzing-a-Monte-Carlo-Experiment-1">Analyzing a Monte Carlo Experiment</a></li></ul></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/e27db7aff4da909f36b21c269fb48975460a37ec/docs/src/features/monte_carlo.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Parallel-Monte-Carlo-Simulations-1" href="#Parallel-Monte-Carlo-Simulations-1">Parallel Monte Carlo Simulations</a></h1><h2><a class="nav-anchor" id="Performing-a-Monte-Carlo-Simulation-1" href="#Performing-a-Monte-Carlo-Simulation-1">Performing a Monte Carlo Simulation</a></h2><h3><a class="nav-anchor" id="Building-a-Problem-1" href="#Building-a-Problem-1">Building a Problem</a></h3><p>To perform a Monte Carlo simulation, define a <code>MonteCarloProblem</code>. The constructor is:</p><pre><code class="language-julia">MonteCarloProblem(prob::DEProblem;
                  output_func = (sol,i) -&gt; sol,
                  prob_func= (prob,i)-&gt;prob)</code></pre><ul><li><p><code>prob_func</code>: The function by which the problem is to be modified.</p></li><li><p><code>output_func</code>: The reduction function.</p></li></ul><p>One can specify a function <code>prob_func</code> which changes the problem. For example:</p><pre><code class="language-julia">function prob_func(prob,i)
  prob.u0 = randn()*prob.u0
  prob
end</code></pre><p>modifies the initial condition for all of the problems by a standard normal random number (a different random number per simulation). This can be used to perform searches over initial values. Note that the parameter <code>i</code> is a unique counter over the simulations. Thus if you have an array of initial conditions <code>u0_arr</code>, you can have the <code>i</code>th simulation use the <code>i</code>th initial condition via:</p><pre><code class="language-julia">function prob_func(prob,i)
  prob.u0 = u0_arr[i]
  prob
end</code></pre><p>If your function is a <code>ParameterizedFunction</code>, you can do similar modifications to <code>prob.f</code> to perform a parameter search. The <code>output_func</code> is a reduction function. It&#39;s arguments are the generated solution and the unique index for the run. For example, if we wish to only save the 2nd coordinate at the end of each solution, we can do:</p><pre><code class="language-julia">output_func(sol,i) = sol[end,2]</code></pre><p>Thus the Monte Carlo Simulation would return as its data an array which is the end value of the 2nd dependent variable for each of the runs.</p><h3><a class="nav-anchor" id="Parameterizing-the-Monte-Carlo-Components-1" href="#Parameterizing-the-Monte-Carlo-Components-1">Parameterizing the Monte Carlo Components</a></h3><p>The Monte Carlo components can be parameterized by using the <code>ConcreteParameterizedFunction</code> constructors.</p><pre><code class="language-julia">ProbParameterizedFunction(prob_func,params)
OutputParameterizedFunction(output_func,params)</code></pre><p>Here, the signatures are <code>prob_func(prob,i,params)</code> and <code>output_func(sol,params)</code>. These parameters are added to the parameter list for use in the parameter estimation schemes.</p><h3><a class="nav-anchor" id="Solving-the-Problem-1" href="#Solving-the-Problem-1">Solving the Problem</a></h3><pre><code class="language-julia">sim = solve(prob,alg,kwargs...)</code></pre><p>The keyword arguments take in the arguments for the common solver interface and will pass them to the differential equation solver. The special keyword arguments to note are:</p><ul><li><p><code>num_monte</code>: The number of simulations to run. Default is 10,000.</p></li><li><p><code>parallel_type</code> : The type of parallelism to employ. Default is <code>:pmap</code>.</p></li></ul><p>The types of parallelism included are:</p><ul><li><p><code>:none</code> - No parallelism</p></li><li><p><code>:threads</code> - This uses multithreading. It&#39;s local (single computer, shared memory) parallelism only. Fastest when the trajectories are quick.</p></li><li><p><code>:parfor</code> - A multiprocessing parallelism. Slightly better than <code>pmap</code> when the calculations are fast. Does not re-distribute work: each trajectory is assumed to take as long to calculate.</p></li><li><p><code>:pmap</code> - The default. Uses <code>pmap</code> internally. It will use as many processors as you have Julia processes. To add more processes, use <code>addprocs(n)</code>. See Julia&#39;s documentation for more details. Recommended for the case when each trajectory calculation isn&#39;t &quot;too quick&quot; (at least about a millisecond each?).</p></li><li><p><code>:split_threads</code> - This uses threading on each process, splitting the problem into <code>nprocs()</code> even parts. This is for solving many quick trajectories on a multi-node machine. It&#39;s recommended you have one process on each node.</p></li></ul><p>Additionally, a <code>MonteCarloEstimator</code> can be supplied</p><pre><code class="language-julia">sim = solve(prob,estimator,alg,kwargs...)</code></pre><p>These will be detailed when implemented.</p><h3><a class="nav-anchor" id="Solution-Type-1" href="#Solution-Type-1">Solution Type</a></h3><p>The resulting type is a <code>MonteCarloSimulation</code>, which includes the array of solutions. If the problem was a <code>TestProblem</code>, summary statistics on the errors are returned as well.</p><h3><a class="nav-anchor" id="Plot-Recipe-1" href="#Plot-Recipe-1">Plot Recipe</a></h3><p>There is a plot recipe for a <code>AbstractMonteCarloSimulation</code> which composes all of the plot recipes for the component solutions. The keyword arguments are passed along. A useful argument to use is <code>linealpha</code> which will change the transparency of the plots. An additional argument is <code>idxs</code> which allows you to choose which components of the solution to plot. For example, if the differential equation is a vector of 9 values, <code>idxs=1:2:9</code> will plot only the Monte Carlo solutions of the odd components.</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Let&#39;s test the sensitivity of the linear ODE to its initial condition.</p><pre><code class="language-julia">addprocs(4)
using DiffEqMonteCarlo, DiffEqBase, DiffEqProblemLibrary, OrdinaryDiffEq
prob = prob_ode_linear
prob_func = function (prob)
  prob.u0 = rand()*prob.u0
  prob
end
monte_prob = MonteCarloProblem(prob,prob_func=prob_func)
sim = solve(monte_prob,Tsit5(),num_monte=100)

using Plots
plotly()
plot(sim,linealpha=0.4)</code></pre><p>Here we solve the same ODE 100 times on 4 different cores, jiggling the initial condition by <code>rand()</code>. The resulting plot is as follows:</p><p><img src="../assets/monte_carlo_plot.png" alt="monte_carlo_plot"/></p><h2><a class="nav-anchor" id="Analyzing-a-Monte-Carlo-Experiment-1" href="#Analyzing-a-Monte-Carlo-Experiment-1">Analyzing a Monte Carlo Experiment</a></h2><p>Analysis tools are included for generating summary statistics and summary plots for a <code>MonteCarloSimulation</code>.</p><h3><a class="nav-anchor" id="Time-steps-vs-time-points-1" href="#Time-steps-vs-time-points-1">Time steps vs time points</a></h3><p>For the summary statistics, there are two types. You can either summarize by time steps or by time points. Summarizing by time steps assumes that the time steps are all the same time point, i.e. the integrator used a fixed <code>dt</code> or the values were saved using <code>saveat</code>. Summarizing by time points requires interpolating the solution.</p><h3><a class="nav-anchor" id="Analysis-at-a-time-step-or-time-point-1" href="#Analysis-at-a-time-step-or-time-point-1">Analysis at a time step or time point</a></h3><pre><code class="language-julia">get_timestep(sim,i) # Returns an iterator of each simulation at time step i
get_timepoint(sim,t) # Returns an iterator of each simulation at time point t
componentwise_vectors_timestep(sim,i) # Returns a vector of each simulation at time step i
componentwise_vectors_timepoint(sim,t) # Returns a vector of each simulation at time point t</code></pre><h3><a class="nav-anchor" id="Summary-Statistics-1" href="#Summary-Statistics-1">Summary Statistics</a></h3><h4><a class="nav-anchor" id="Single-Time-Statistics-1" href="#Single-Time-Statistics-1">Single Time Statistics</a></h4><p>The available functions for time steps are:</p><pre><code class="language-julia">timestep_mean(sim,i) # Computes the mean of each component at time step i
timestep_median(sim,i) # Computes the median of each component at time step i
timestep_quantile(sim,q,i) # Computes the quantile q of each component at time step i
timestep_meanvar(sim,i)  # Computes the mean and variance of each component at time step i
timestep_meancov(sim,i,j) # Computes the mean at i and j, and the covariance, for each component
timestep_meancor(sim,i,j) # Computes the mean at i and j, and the correlation, for each component
timestep_weighted_meancov(sim,W,i,j) # Computes the mean at i and j, and the weighted covariance W, for each component</code></pre><p>The available functions for time points are:</p><pre><code class="language-julia">timepoint_mean(sim,t) # Computes the mean of each component at time t
timepoint_median(sim,t) # Computes the median of each component at time t
timepoint_quantile(sim,q,t) # Computes the quantile q of each component at time t
timepoint_meanvar(sim,t) # Computes the mean and variance of each component at time t
timepoint_meancov(sim,t1,t2) # Computes the mean at t1 and t2, the covariance, for each component
timepoint_meancor(sim,t1,t2) # Computes the mean at t1 and t2, the correlation, for each component
timepoint_weighted_meancov(sim,W,t1,t2) # Computes the mean at t1 and t2, the weighted covariance W, for each component</code></pre><h4><a class="nav-anchor" id="Full-Timeseries-Statistics-1" href="#Full-Timeseries-Statistics-1">Full Timeseries Statistics</a></h4><p>Additionally, the following functions are provided for analyzing the full timeseries. The <code>mean</code> and <code>meanvar</code> versions return a <code>DiffEqArray</code> which can be directly plotted. The <code>meancov</code> and <code>meancor</code> return a matrix of tuples, where the tuples are the <code>(mean_t1,mean_t2,cov or cor)</code>.</p><p>The available functions for the time steps are:</p><pre><code class="language-julia">timeseries_steps_mean(sim) # Computes the mean at each time step
timeseries_steps_median(sim) # Computes the median at each time step
timeseries_steps_quantile(sim,q) # Computes the quantile q at each time step
timeseries_steps_meanvar(sim) # Computes the mean and variance at each time step
timeseries_steps_meancov(sim) # Computes the covariance matrix and means at each time step
timeseries_steps_meancor(sim) # Computes the correlation matrix and means at each time step
timeseries_steps_weighted_meancov(sim) # Computes the weighted covariance matrix and means at each time step</code></pre><p>The available functions for the time points are:</p><pre><code class="language-julia">timeseries_point_mean(sim,ts) # Computes the mean at each time point in ts
timeseries_point_median(sim,ts) # Computes the median at each time point in ts
timeseries_point_quantile(sim,q,ts) # Computes the quantile q at each time point in ts
timeseries_point_meanvar(sim,ts) # Computes the mean and variance at each time point in ts
timeseries_point_meancov(sim,ts) # Computes the covariance matrix and means at each time point in ts
timeseries_point_meancor(sim,ts) # Computes the correlation matrix and means at each time point in ts
timeseries_point_weighted_meancov(sim,ts) # Computes the weighted covariance matrix and means at each time point in ts</code></pre><h3><a class="nav-anchor" id="MonteCarloSummary-1" href="#MonteCarloSummary-1">MonteCarloSummary</a></h3><p>The <code>MonteCarloSummary</code> type is included to help with analyzing the general summary statistics. Two constructors are provided:</p><pre><code class="language-julia">MonteCarloSummary(sim)
MonteCarloSummary(sim,ts)</code></pre><p>The first produces a <code>(mean,var)</code> summary at each time step. As with the summary statistics, this assumes that the time steps are all the same. The second produces a <code>(mean,var)</code> summary at each time point <code>t</code> in <code>ts</code>. This requires the ability to interpolate the solution.</p><h4><a class="nav-anchor" id="Plot-Recipe-2" href="#Plot-Recipe-2">Plot Recipe</a></h4><p>The <code>MonteCarloSummary</code> comes with a plot recipe for visualizing the summary statistics. The extra keyword arguments are:</p><ul><li><p><code>idxs</code>: the solution components to plot. Defaults to plotting all components.</p></li><li><p><code>error_style</code>: The style for plotting the error. Defaults to <code>ribbon</code>. Other choices are <code>:bars</code> for error bars and <code>:none</code> for no error bars.</p></li></ul><p>One useful argument is <code>fillalpha</code> which controls the transparency of the ribbon around the mean. The confidence interval is the Gaussian CI <code>1.96*var</code>.</p><h3><a class="nav-anchor" id="Example-Analysis-1" href="#Example-Analysis-1">Example Analysis</a></h3><p>In this example we will show how to analyze a <code>MonteCarloSolution</code>. First, let&#39;s generate a 10 solution Monte Carlo experiment:</p><pre><code class="language-julia">prob = prob_sde_2Dlinear
prob2 = MonteCarloProblem(prob)
sim = solve(prob2,SRIW1(),dt=1//2^(3),num_monte=10,adaptive=false)</code></pre><p>The system, <code>prob_sde_2Dlinear</code>, is a <code>(4,2)</code> system of stochastic differential equations which we solved 10 times. We can compute the mean and the variance at the 3rd timestep using:</p><pre><code class="language-julia">m,v = timestep_meanvar(sim,3)</code></pre><p>or we can compute the mean and the variance at the <code>t=0.5</code> using:</p><pre><code class="language-julia">m,v = timepoint_meanvar(sim,0.5)</code></pre><p>We can get a series for the mean and the variance at each time step using:</p><pre><code class="language-julia">m_series,v_series = timeseries_steps_meanvar(sim)</code></pre><p>or at chosen values of <code>t</code>:</p><pre><code class="language-julia">ts = 0:0.1:1
m_series = timeseries_point_mean(sim,ts)</code></pre><p>Note that these mean and variance series can be directly plotted. We can compute covariance matrices similarly:</p><pre><code class="language-julia">timeseries_steps_meancov(sim) # Use the time steps, assume fixed dt
timeseries_point_meancov(sim,0:1//2^(3):1,0:1//2^(3):1) # Use time points, interpolate</code></pre><p>For general analysis, we can build a <code>MonteCarloSummary</code> type.</p><pre><code class="language-julia">summ = MonteCarloSummary(sim)</code></pre><p>will summarize at each time step, while</p><pre><code class="language-julia">summ = MonteCarloSummary(sim,0.0:0.1:1.0)</code></pre><p>will summarize at the <code>0.1</code> time points using the interpolations. To visualize the results we can plot it. Since there are 8 components to the differential equation, this can get messy, so let&#39;s only plot the 3rd component:</p><pre><code class="language-julia">plot(summ;idxs=3)</code></pre><p><img src="../assets/monte_ribbon.png" alt="monte_ribbon"/></p><p>We can change to errorbars instead of ribbons and plot two different indices:</p><pre><code class="language-julia">plot(summ;idxs=(3,5),error_style=:bars)</code></pre><p><img src="../assets/monte_bars.png" alt="monte_bars"/></p><p>Or we can simply plot the mean of every component over time:</p><pre><code class="language-julia">plot(summ;error_style=:none)</code></pre><p><img src="../assets/monte_means.png" alt="monte_means"/></p><footer><hr/><a class="previous" href="callback_library.html"><span class="direction">Previous</span><span class="title">Callback Library</span></a><a class="next" href="io.html"><span class="direction">Next</span><span class="title">I/O: Saving and Loading Solution Data</span></a></footer></article></body></html>
