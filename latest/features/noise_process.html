<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise Processes · DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Equation Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Types</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Types</a></li><li><a class="toctext" href="../types/refined_ode_types.html">Refined ODE Types</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Types</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Types</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Types</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Types</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Types</a></li><li><a class="toctext" href="../types/refined_dae_types.html">Refined DAE Types</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Types</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Types</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li class="current"><a class="toctext" href="noise_process.html">Noise Processes</a><ul class="internal"><li><a class="toctext" href="#Noise-Process-Interface-1">Noise Process Interface</a></li><li><a class="toctext" href="#Noise-Process-Types-1">Noise Process Types</a></li><li><a class="toctext" href="#Example-Using-Noise-Processes-1">Example Using Noise Processes</a></li></ul></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="noise_process.html">Noise Processes</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/eb4f365b4993b9a42d98bd5a0289c4d1ccffd8bc/docs/src/features/noise_process.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Noise-Processes-1" href="#Noise-Processes-1">Noise Processes</a></h1><p>A <code>NoiseProcess</code> is a type defined as</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,dist,bridge;
             iip=DiffEqBase.isinplace(dist,3),
             rswm = RSWM())</code></pre><ul><li><p><code>t0</code> is the first timepoint</p></li><li><p><code>W0</code> is the first value of the process.</p></li><li><p><code>Z0</code> is the first value of the psudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</p></li><li><p><code>dist</code> the distribution for the steps over time.</p></li><li><p><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</p></li></ul><p>The signature for the <code>dist</code> is</p><pre><code class="language-julia">dist!(rand_vec,W,dt)</code></pre><p>for inplace functions, and</p><pre><code class="language-julia">rand_vec = dist(W,dt)</code></pre><p>otherwise. The signature for <code>bridge</code> is</p><pre><code class="language-julia">bridge!(rand_vec,W,W0,Wh,q,h)</code></pre><p>and the out of place syntax is</p><pre><code class="language-julia">rand_vec = bridge!(W,W0,Wh,q,h)</code></pre><p>Here, <code>W</code> is the noise process, <code>W0</code> is the left side of the current interval, <code>Wh</code> is the right side of the current interval, <code>h</code> is the interval length, and <code>q</code> is the proportion from the left where the interpolation is occuring.</p><h2><a class="nav-anchor" id="Noise-Process-Interface-1" href="#Noise-Process-Interface-1">Noise Process Interface</a></h2><h3><a class="nav-anchor" id="Basic-Interface-1" href="#Basic-Interface-1">Basic Interface</a></h3><p>The <code>NoiseProcess</code> acts like a DiffEq solution. For some noise process <code>W</code>, you can get its <code>i</code>th timepoint like <code>W[i]</code> and the associated time <code>W.t[i]</code>. If the <code>NoiseProcess</code> has a bridging distribution defined, it can be interpolated to arbitrary time points using <code>W(t)</code>. Note that every interpolated value is saved to the <code>NoiseProcess</code> so that way it can stay distributionally correct. A plot recipe is provided which plots the timeseries.</p><h3><a class="nav-anchor" id="Direct-Simulation-of-the-Noise-Process-1" href="#Direct-Simulation-of-the-Noise-Process-1">Direct Simulation of the Noise Process</a></h3><p>Since the <code>NoiseProcess</code> types are distribution-exact and do not require the stochastic differential equation solvers, many times one would like to directly simulate trajectories from these proecesses. The <code>NoiseProcess</code> has a <code>NoiseProcessProblem</code> type:</p><pre><code class="language-julia">NoiseProblem(noise,tspan)</code></pre><p>for which <code>solve</code> works. For example, we can simulate a distributionally-exact Geometric Brownian Motion solution by:</p><pre><code class="language-julia">μ = 1.0
σ = 2.0
W = GeometricBrownianMotionProcess(μ,σ,0.0,1.0,1.0)
prob = NoiseProblem(W,(0.0,1.0))
sol = solve(prob;dt=0.1)</code></pre><p><code>solve</code> requires the <code>dt</code> is given, the solution it returns is a <code>NoiseProcess</code> which has stepped through the timespan. Because this follows the common interface, all of the normal functionality works. For example, we can use the Monte Carlo functionality as follows:</p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
sol = solve(monte_prob;dt=0.1,num_monte=100)</code></pre><p>simulates 100 Geometric Brownian Motions.</p><h3><a class="nav-anchor" id="Direct-Interface-1" href="#Direct-Interface-1">Direct Interface</a></h3><p>Most of the time, a <code>NoiseProcess</code> is received from the solution of a stochastic or random differential equation, in which case <code>sol.W</code> gives the <code>NoiseProcess</code> and it is already defined along some timeseries. In other cases, <code>NoiseProcess</code> types are directly simulated (see below). However, <code>NoiseProcess</code> types can also be directly acted on. The basic functionality is given by <code>calculate_step!</code> to calculate a future time point, and <code>accept_step!</code> to accept the step. If steps are rejected, the Rejection Sampling with Memory algorithm is applied to keep the solution distributionally exact. This kind of stepping is done via:</p><pre><code class="language-julia">W = WienerProcess(0.0,1.0,1.0)
dt = 0.1
calculate_step!(W,dt)
for i in 1:10
  accept_step!(W,dt)
end</code></pre><h2><a class="nav-anchor" id="Noise-Process-Types-1" href="#Noise-Process-Types-1">Noise Process Types</a></h2><p>This section describes the available <code>NoiseProcess</code> types.</p><h3><a class="nav-anchor" id="White-Noise-1" href="#White-Noise-1">White Noise</a></h3><p>The default noise is <code>WHITE_NOISE</code>. This is the noise process which uses <code>randn!</code>. A special dispatch is added for complex numbers for <code>(randn()+im*randn())/sqrt(2)</code>. This function is <code>DiffEqBase.wiener_randn</code> (or with <code>!</code> respectively). Thus its noise function is essentially:</p><pre><code class="language-julia">function WHITE_NOISE_DIST(W,dt)
  if typeof(W.dW) &lt;: AbstractArray
    return sqrt(abs(dt))*wiener_randn(size(W.dW))
  else
    return sqrt(abs(dt))*wiener_randn(typeof(W.dW))
  end
end
function WHITE_NOISE_BRIDGE(W,W0,Wh,q,h)
  sqrt((1-q)*q*abs(h))*wiener_randn(typeof(W.dW))+q*(Wh-W0)+W0
end</code></pre><p>for the out of place versions, and for the inplace versions</p><pre><code class="language-julia">function INPLACE_WHITE_NOISE_DIST(rand_vec,W,dt)
  wiener_randn!(rand_vec)
  rand_vec .*= sqrt(abs(dt))
end
function INPLACE_WHITE_NOISE_BRIDGE(rand_vec,W,W0,Wh,q,h)
  wiener_randn!(rand_vec)
  rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*(Wh.-W0).+W0
end</code></pre><p>Notice these functions correspond to the distributions for the Wiener process, that is the first one is simply that Brownian steps are distributed <code>N(0,dt)</code>, while the second function is the distribution of the Brownian Bridge <code>N(q(Wh-W0)+W0,(1-q)qh)</code>. These functions are then placed in a noise process:</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE,rswm=RSWM())
NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE,rswm=RSWM())</code></pre><p>For convenience, the following constructors are predefined:</p><pre><code class="language-julia">WienerProcess(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE,rswm=RSWM())
WienerProcess!(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE,rswm=RSWM())</code></pre><p>These will generate a Wiener process, which can be stepped with <code>step!(W,dt)</code>, and interpolated as <code>W(t)</code>.</p><h3><a class="nav-anchor" id="Correlated-Noise-1" href="#Correlated-Noise-1">Correlated Noise</a></h3><p>One can define a <code>CorrelatedWienerProcess</code> which is a Wiener process with correlations between the Wiener processes. The constructor is:</p><pre><code class="language-julia">CorrelatedWienerProcess(Γ,t0,W0,Z0=nothing)
CorrelatedWienerProcess!(Γ,t0,W0,Z0=nothing)</code></pre><p>where <code>Γ</code> is the constant covariance matrix.</p><h3><a class="nav-anchor" id="Geometric-Brownian-Motion-1" href="#Geometric-Brownian-Motion-1">Geometric Brownian Motion</a></h3><p>One can define a <code>GeometricBrownianMotion</code> process which is a Wiener process with constant drift <code>μ</code> and constant diffusion <code>σ</code>. I.e. this is the solution of the stochastic differential equation</p><pre><code class="language-julia">dX_t = \mu X_t dt + \sigma X_t dW_t</code></pre><p>The <code>GeometricBrownianMotionProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:</p><pre><code class="language-julia">GeometricBrownianMotionProcess(μ,σ,t0,W0,Z0=nothing)
GeometricBrownianMotionProcess!(μ,σ,t0,W0,Z0=nothing)</code></pre><h3><a class="nav-anchor" id="Ornstein-Uhlenbeck-1" href="#Ornstein-Uhlenbeck-1">Ornstein-Uhlenbeck</a></h3><p>One can define a <code>Ornstein-Uhlenbeck</code> process which is a Wiener process defined by the stochastic differential equation</p><pre><code class="language-julia">dX_t = \theta (\mu - X_t) dt + \sigma X_t dW_t</code></pre><p>The <code>OrnsteinUhlenbeckProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). The constructor is:</p><pre><code class="language-julia">OrnsteinUhlenbeckProcess(Θ,μ,σ,t0,W0,Z0=nothing)
OrnsteinUhlenbeckProcess!(Θ,μ,σ,t0,W0,Z0=nothing)</code></pre><h3><a class="nav-anchor" id="NoiseWrapper-1" href="#NoiseWrapper-1">NoiseWrapper</a></h3><p>Another <code>AbstractNoiseProcess</code> is the <code>NoiseWrapper</code>. This produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to re-use a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.</p><p>To wrap a noise process, simply use:</p><pre><code class="language-julia">NoiseWrapper(W::NoiseProcess)</code></pre><h2><a class="nav-anchor" id="Example-Using-Noise-Processes-1" href="#Example-Using-Noise-Processes-1">Example Using Noise Processes</a></h2><h3><a class="nav-anchor" id="Noise-Wrapper-Example-1" href="#Noise-Wrapper-Example-1">Noise Wrapper Example</a></h3><p>In this example, we will solve an SDE three times:</p><ul><li><p>First to generate a noise process</p></li><li><p>Second with the same timesteps to show the values are the same</p></li><li><p>Third with half-sized timsteps</p></li></ul><p>First we will generate a noise process by solving an SDE:</p><pre><code class="language-julia">using StochasticDiffEq,  DiffEqBase, DiffEqNoiseProcess
f1 = (t,u) -&gt; 1.01u
g1 = (t,u) -&gt; 1.01u
dt = 1//2^(4)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0))
sol1 = solve(prob1,EM(),dt=dt)</code></pre><p>Now we wrap the noise into a NoiseWrapper and solve the same problem:</p><pre><code class="language-julia">W2 = NoiseWrapper(sol1.W)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W2)
sol2 = solve(prob1,EM(),dt=dt)</code></pre><p>We can test</p><pre><code class="language-julia">@test sol1.u ≈ sol2.u</code></pre><p>to see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller <code>dt</code>:</p><pre><code class="language-julia">W3 = NoiseWrapper(sol1.W)
prob2 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W3)

dt = 1//2^(5)
sol3 = solve(prob2,EM(),dt=dt)</code></pre><p>We can plot the results to see what this looks like:</p><pre><code class="language-julia">using Plots
plot(sol1)
plot!(sol2)
plot!(sol3)</code></pre><p><img src="../assets/noise_process.png" alt="noise_process"/></p><p>In this plot, <code>sol2</code> covers up <code>sol1</code> because they hit essentially the same values. You can see that <code>sol3</code> its similar to the others, because it&#39;s using the same underlying noise process just sampled much finer.</p><p>To double check, we see that:</p><pre><code class="language-julia">plot(sol1.W)
plot!(sol2.W)
plot!(sol3.W)</code></pre><p><a href="../assets/coupled_wiener.png">coupled_wiener</a></p><p>the coupled Wiener processes coincide at every other timepoint, and the intermediate timepoints were calculated according to a Brownian bridge.</p><h3><a class="nav-anchor" id="Adaptive-Example-1" href="#Adaptive-Example-1">Adaptive Example</a></h3><p>Here we will show that the same noise can be used with the adaptive methods using the <code>NoiseWrapper</code>. <code>SRI</code> and <code>SRIW1</code> use slightly different error estimators, and thus give slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:</p><pre><code class="language-julia">prob = SDEProblem(f1,g1,ones(2),(0.0,1.0))
sol4 = solve(prob,SRI(),abstol=1e-8)

W2 = NoiseWrapper(sol4.W)
prob2 = SDEProblem(f1,g1,ones(2),(0.0,1.0),noise=W2)
sol5 = solve(prob2,SRIW1(),abstol=1e-8)

using Plots
plot(sol4)
plot!(sol5)</code></pre><p><img src="../assets/SRI_SRIW1_diff.png" alt="SRI_SRIW1_diff"/></p><footer><hr/><a class="previous" href="diffeq_arrays.html"><span class="direction">Previous</span><span class="title">DiffEq-Specific Array Types</span></a><a class="next" href="linear_nonlinear.html"><span class="direction">Next</span><span class="title">Specifying (Non)Linear Solvers</span></a></footer></article></body></html>
